"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCircularDefinitionsValidator = exports.getPropertyTypesValidator = exports.getTypeDefinitionsValidator = void 0;
var typeInfo_1 = require("../typeInfo");
var graphql_schema_cycles_1 = require("@dorgjelli/graphql-schema-cycles");
var operationTypeNames = ["Mutation", "Subscription", "Query"];
exports.getTypeDefinitionsValidator = function () {
    var objectTypes = {};
    return {
        visitor: {
            enter: {
                // No Interfaces
                InterfaceTypeDefinition: function (node) {
                    throw Error("Interface type definitions are not supported.\n" +
                        ("Found: interface " + node.name.value + " { ... }\n") +
                        ("Please Use: type " + node.name.value + " { ... }"));
                },
                // No Inputs
                InputObjectTypeDefinition: function (node) {
                    throw Error("Input type definitions are not supported.\n" +
                        ("Found: input " + node.name.value + " { ... }\n") +
                        ("Please Use: type " + node.name.value + " { ... }"));
                },
                ObjectTypeDefinition: function (node) {
                    // No Operation types
                    if (operationTypeNames.includes(node.name.value)) {
                        throw Error("OperationType names (" + operationTypeNames.join(", ") + ") are not allowed.");
                    }
                    // No duplicates
                    if (objectTypes[node.name.value]) {
                        throw Error("Duplicate object type definition found: " + node.name.value);
                    }
                    objectTypes[node.name.value] = true;
                },
                // No New Scalars
                ScalarTypeDefinition: function (node) {
                    if (node.name.value !== "Map" && !typeInfo_1.isScalarType(node.name.value)) {
                        throw Error("Custom scalar types are not supported. Found: \"" + node.name.value + "\". Supported scalars: " + typeInfo_1.scalarTypeNames);
                    }
                },
                // No Unions
                UnionTypeDefinition: function (node) {
                    throw Error("Union type definitions are not supported.\n" +
                        ("Found: union " + node.name.value));
                },
            },
        },
    };
};
exports.getPropertyTypesValidator = function () {
    var currentObject;
    var currentImportType;
    var currentField;
    var objectTypes = {};
    var enumTypes = {};
    var duplicateFields = {};
    var fieldTypes = [];
    return {
        visitor: {
            enter: {
                ObjectTypeDefinition: function (node) {
                    var e_1, _a;
                    currentObject = node.name.value;
                    objectTypes[node.name.value] = true;
                    if (node.fields) {
                        var fields = {};
                        try {
                            for (var _b = __values(node.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var field = _c.value;
                                if (fields[field.name.value]) {
                                    if (!duplicateFields[node.name.value]) {
                                        duplicateFields[node.name.value] = {};
                                    }
                                    duplicateFields[node.name.value][field.name.value] = true;
                                }
                                fields[field.name.value] = true;
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                },
                EnumTypeDefinition: function (node) {
                    enumTypes[node.name.value] = true;
                },
                Directive: function (node) {
                    if (node.name.value === "imported") {
                        // save the imported native type name
                        if (node.arguments) {
                            var nativeType = node.arguments.find(function (arg) { return arg.name.value === "nativeType"; });
                            if (nativeType) {
                                currentImportType = nativeType.value.value;
                            }
                        }
                    }
                },
                FieldDefinition: function (node) {
                    if (node.name.value === "sanitizeEnv") {
                        return;
                    }
                    currentField = node.name.value;
                },
                NamedType: function (node) {
                    if (currentObject && currentField) {
                        fieldTypes.push({
                            object: currentObject,
                            field: currentField,
                            type: node.name.value,
                        });
                    }
                },
                InputValueDefinition: function (node) {
                    var typeName = currentImportType
                        ? currentImportType
                        : currentObject;
                    if (typeName && !typeInfo_1.isModuleType(typeName)) {
                        // Arguments not supported on non-module types
                        throw Error("Methods can only be defined on module types (Module).\n" +
                            ("Found: type " + typeName + " { " + currentField + "(" + node.name.value + ") }"));
                    }
                },
            },
            leave: {
                ObjectTypeDefinition: function () {
                    currentObject = undefined;
                    currentImportType = undefined;
                },
                FieldDefinition: function () {
                    currentField = undefined;
                },
            },
        },
        cleanup: function () {
            var e_2, _a;
            try {
                // Ensure all property types are either a
                // supported scalar, enum or an object type definition
                for (var fieldTypes_1 = __values(fieldTypes), fieldTypes_1_1 = fieldTypes_1.next(); !fieldTypes_1_1.done; fieldTypes_1_1 = fieldTypes_1.next()) {
                    var field = fieldTypes_1_1.value;
                    if (!typeInfo_1.isScalarType(field.type) &&
                        !objectTypes[field.type] &&
                        !enumTypes[field.type] &&
                        field.type !== "Map") {
                        throw Error("Unknown property type found: type " + field.object + " { " + field.field + ": " + field.type + " }");
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (fieldTypes_1_1 && !fieldTypes_1_1.done && (_a = fieldTypes_1.return)) _a.call(fieldTypes_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var objectTypeNames = Object.keys(duplicateFields);
            if (objectTypeNames.length) {
                throw new Error("Found duplicate fields in the following objects:" + objectTypeNames.map(function (object) {
                    return "\ntype " + object + " => " + JSON.stringify(Object.keys(duplicateFields[object]));
                }));
            }
        },
    };
};
function getCircularDefinitionsValidator() {
    var operationTypes = [];
    return {
        visitor: {
            enter: {
                ObjectTypeDefinition: function (node) {
                    var isOperationType = operationTypeNames.some(function (name) {
                        return node.name.value === name || node.name.value.endsWith("_" + name);
                    });
                    if (isOperationType) {
                        operationTypes.push(node.name.value);
                    }
                },
            },
        },
        cleanup: function (documentNode) {
            var _a = graphql_schema_cycles_1.getSchemaCycles(documentNode, {
                ignoreTypeNames: operationTypes,
                allowOnNullableFields: true,
            }), cycleStrings = _a.cycleStrings, foundCycle = _a.foundCycle;
            if (foundCycle) {
                throw Error("Graphql cycles are not supported. \nFound: " + cycleStrings.map(function (cycle) { return "\n- " + cycle; }));
            }
        },
    };
}
exports.getCircularDefinitionsValidator = getCircularDefinitionsValidator;
//# sourceMappingURL=types.js.map