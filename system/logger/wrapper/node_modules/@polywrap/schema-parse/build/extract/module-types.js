"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleTypesVisitor = void 0;
var typeInfo_1 = require("../typeInfo");
var module_types_utils_1 = require("./utils/module-types-utils");
var object_types_utils_1 = require("./utils/object-types-utils");
var visitorEnter = function (typeInfo, state) { return ({
    ObjectTypeDefinition: function (node) {
        var _a, _b;
        var nodeName = node.name.value;
        if (nodeName !== "Module") {
            return;
        }
        var imports = parseImportsDirective(nodeName, node);
        var interfaces = parseCapabilitiesDirective(nodeName, node);
        state.currentInterfaces = interfaces;
        var module = typeInfo_1.createModuleDefinition({
            imports: imports,
            interfaces: (_a = node.interfaces) === null || _a === void 0 ? void 0 : _a.map(function (x) {
                return typeInfo_1.createInterfaceImplementedDefinition({ type: x.name.value });
            }),
            comment: (_b = node.description) === null || _b === void 0 ? void 0 : _b.value,
        });
        typeInfo.moduleType = module;
        state.currentModule = module;
    },
    FieldDefinition: function (node) {
        var _a;
        var module = state.currentModule;
        if (!module) {
            return;
        }
        var name = node.name.value;
        var _b = object_types_utils_1.extractAnnotateDirective(node, name), type = _b.type, def = _b.def;
        var returnType = typeInfo_1.createPropertyDefinition({
            type: type ? type : "N/A",
            name: node.name.value,
            map: def
                ? __assign(__assign({}, def), { name: node.name.value })
                : undefined,
            required: def && def.required ? true : false,
        });
        var method = typeInfo_1.createMethodDefinition({
            name: node.name.value,
            return: returnType,
            comment: (_a = node.description) === null || _a === void 0 ? void 0 : _a.value,
        });
        module.methods.push(method);
        state.currentMethod = method;
        state.currentReturn = returnType;
    },
    InputValueDefinition: function (node) {
        module_types_utils_1.extractInputValueDefinition(node, state);
    },
    NonNullType: function (_node) {
        state.nonNullType = true;
    },
    NamedType: function (node) {
        module_types_utils_1.extractNamedType(node, state);
    },
    ListType: function (_node) {
        module_types_utils_1.extractListType(state);
    },
}); };
var parseCapabilitiesDirective = function (nodeName, node) {
    var e_1, _a;
    var interfaces = [];
    var interfacesByNamespace = {};
    if (!node.directives) {
        return interfaces;
    }
    try {
        for (var _b = __values(node.directives), _c = _b.next(); !_c.done; _c = _b.next()) {
            var dir = _c.value;
            if (dir.name.value !== "capability") {
                continue;
            }
            if (!dir.arguments) {
                throw Error("@capability directive is incomplete, missing arguments. See type " + nodeName + ".");
            }
            var typeIndex = dir.arguments.findIndex(function (arg) { return arg.name.value === "type"; });
            if (typeIndex === -1) {
                throw Error("@capability directive missing required argument \"type\". See type " + nodeName + ".");
            }
            var typeArg = dir.arguments[typeIndex];
            if (typeArg.value.kind !== "StringValue") {
                throw Error("@capability directive's \"type\" argument must be a String type. See type " + nodeName + ".");
            }
            if (!typeInfo_1.capabilityTypes.includes(typeArg.value.value)) {
                throw Error("@capability directive's \"type\" argument must be one from " + JSON.stringify(typeInfo_1.capabilityTypes) + ". See type " + nodeName + ".");
            }
            var capabilityType = typeArg.value.value;
            var uriIndex = dir.arguments.findIndex(function (arg) { return arg.name.value === "uri"; });
            if (uriIndex === -1) {
                throw Error("@capability directive missing required argument \"uri\". See type " + nodeName + ".");
            }
            var uriArg = dir.arguments[uriIndex];
            if (uriArg.value.kind !== "StringValue") {
                throw Error("@capability directive's \"uri\" argument must be a String type. See type " + nodeName + ".");
            }
            var uri = uriArg.value.value;
            var namespaceIndex = dir.arguments.findIndex(function (arg) { return arg.name.value === "namespace"; });
            if (namespaceIndex === -1) {
                throw Error("@capability directive missing required argument \"namespace\". See type " + nodeName + ".");
            }
            var namespaceArg = dir.arguments[namespaceIndex];
            if (namespaceArg.value.kind !== "StringValue") {
                throw Error("@capability directive's \"namespace\" argument must be a String type. See type " + nodeName + ".");
            }
            var namespace = namespaceArg.value.value;
            if (!interfacesByNamespace[namespace]) {
                interfacesByNamespace[namespace] = typeInfo_1.createInterfaceDefinition({
                    type: namespace,
                    uri: uri,
                    namespace: namespace,
                    capabilities: typeInfo_1.createCapability({
                        type: capabilityType,
                        enabled: true,
                    }),
                });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Array.from(Object.values(interfacesByNamespace));
};
var parseImportsDirective = function (nodeName, node) {
    // Look for the imports directive, and gather imported types
    var imports = [];
    if (!node.directives) {
        return imports;
    }
    var importsIndex = node.directives.findIndex(function (dir) { return dir.name.value === "imports"; });
    if (importsIndex !== -1) {
        var importsDir = node.directives[importsIndex];
        if (!importsDir.arguments) {
            throw Error("@imports directive is incomplete, missing arguments. See type " + nodeName + ".");
        }
        var typesIndex = importsDir.arguments.findIndex(function (arg) { return arg.name.value === "types"; });
        if (typesIndex === -1) {
            throw Error("@imports directive missing required argument \"types\". See type " + nodeName + ".");
        }
        var typesArg = importsDir.arguments[typesIndex];
        if (typesArg.value.kind !== "ListValue") {
            throw Error("@imports directive's \"types\" argument must be a List type. See type " + nodeName + ".");
        }
        var listValue = typesArg.value;
        listValue.values.forEach(function (value) {
            if (value.kind !== "StringValue") {
                throw Error("@imports directive's \"types\" list must only contain strings. See type " + nodeName + ".");
            }
            imports.push({ type: value.value });
        });
    }
    return imports;
};
var visitorLeave = function (typeInfo, state) { return ({
    ObjectTypeDefinition: function (_node) {
        if (state.currentInterfaces) {
            typeInfo.interfaceTypes = __spread(typeInfo.interfaceTypes, state.currentInterfaces);
        }
        state.currentInterfaces = undefined;
        state.currentModule = undefined;
    },
    FieldDefinition: function (_node) {
        state.currentMethod = undefined;
        state.currentReturn = undefined;
    },
    InputValueDefinition: function (_node) {
        state.currentArgument = undefined;
    },
    NonNullType: function (_node) {
        state.nonNullType = false;
    },
}); };
exports.getModuleTypesVisitor = function (typeInfo) {
    var state = {};
    return {
        enter: visitorEnter(typeInfo, state),
        leave: visitorLeave(typeInfo, state),
    };
};
//# sourceMappingURL=module-types.js.map