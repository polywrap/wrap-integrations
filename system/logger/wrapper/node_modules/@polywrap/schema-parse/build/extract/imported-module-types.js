"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImportedModuleTypesVisitor = void 0;
var typeInfo_1 = require("../typeInfo");
var imported_types_utils_1 = require("./utils/imported-types-utils");
var module_types_utils_1 = require("./utils/module-types-utils");
var object_types_utils_1 = require("./utils/object-types-utils");
var visitorEnter = function (importedModuleTypes, state) { return ({
    ObjectTypeDefinition: function (node) {
        var _a, _b;
        var imported = imported_types_utils_1.extractImportedDefinition(node, true);
        if (!imported) {
            return;
        }
        var dir = node.directives &&
            node.directives.find(function (dir) { return dir.name.value === "enabled_interface"; });
        var isInterface = dir ? true : false;
        var importedType = typeInfo_1.createImportedModuleDefinition({
            uri: imported.uri,
            namespace: imported.namespace,
            nativeType: imported.nativeType,
            isInterface: isInterface,
            interfaces: (_a = node.interfaces) === null || _a === void 0 ? void 0 : _a.map(function (x) {
                return typeInfo_1.createInterfaceImplementedDefinition({ type: x.name.value });
            }),
            comment: (_b = node.description) === null || _b === void 0 ? void 0 : _b.value,
        });
        importedModuleTypes.push(importedType);
        state.currentImport = importedType;
    },
    FieldDefinition: function (node) {
        var _a;
        var importDef = state.currentImport;
        if (!importDef) {
            return;
        }
        var name = node.name.value;
        var _b = object_types_utils_1.extractAnnotateDirective(node, name), type = _b.type, def = _b.def;
        var returnType = typeInfo_1.createPropertyDefinition({
            type: type ? type : "N/A",
            name: node.name.value,
            map: def
                ? __assign(__assign({}, def), { name: node.name.value })
                : undefined,
            required: def && def.required ? true : false,
        });
        var method = typeInfo_1.createMethodDefinition({
            name: node.name.value,
            return: returnType,
            comment: (_a = node.description) === null || _a === void 0 ? void 0 : _a.value,
        });
        importDef.methods.push(method);
        state.currentMethod = method;
        state.currentReturn = returnType;
    },
    InputValueDefinition: function (node) {
        module_types_utils_1.extractInputValueDefinition(node, state);
    },
    NonNullType: function (_node) {
        state.nonNullType = true;
    },
    NamedType: function (node) {
        module_types_utils_1.extractNamedType(node, state);
    },
    ListType: function (_node) {
        module_types_utils_1.extractListType(state);
    },
}); };
var visitorLeave = function (state) { return ({
    ObjectTypeDefinition: function (_node) {
        state.currentImport = undefined;
    },
    FieldDefinition: function (_node) {
        state.currentMethod = undefined;
        state.currentReturn = undefined;
    },
    InputValueDefinition: function (_node) {
        state.currentArgument = undefined;
    },
    NonNullType: function (_node) {
        state.nonNullType = false;
    },
}); };
exports.getImportedModuleTypesVisitor = function (typeInfo) {
    var state = {};
    return {
        enter: visitorEnter(typeInfo.importedModuleTypes, state),
        leave: visitorLeave(state),
    };
};
//# sourceMappingURL=imported-module-types.js.map