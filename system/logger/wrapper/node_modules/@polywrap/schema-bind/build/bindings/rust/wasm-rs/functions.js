"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectKeyword = exports.toWasm = exports.toWasmInit = exports.toMsgPack = exports.noBox = exports.toUpper = exports.toLower = void 0;
var types_1 = require("./types");
function replaceAt(str, index, replacement) {
    return (str.substr(0, index) + replacement + str.substr(index + replacement.length));
}
function insertAt(str, index, insert) {
    return str.substr(0, index) + insert + str.substr(index);
}
function removeAt(str, index) {
    return str.substr(0, index) + str.substr(index + 1);
}
exports.toLower = function () {
    return function (value, render) {
        var type = render(value);
        for (var i = 0; i < type.length; ++i) {
            var char = type.charAt(i);
            var lower = char.toLowerCase();
            if (char !== lower) {
                // Replace the uppercase char w/ the lowercase version
                type = replaceAt(type, i, lower);
                if (i !== 0 && type[i - 1] !== "_") {
                    // Make sure all lowercase conversions have an underscore before them
                    type = insertAt(type, i, "_");
                }
            }
        }
        return type;
    };
};
exports.toUpper = function () {
    return function (value, render) {
        var type = render(value);
        // First character must always be upper case
        var firstChar = type.charAt(0);
        var firstUpper = firstChar.toUpperCase();
        type = replaceAt(type, 0, firstUpper);
        // Look for any underscores, remove them if they exist, and make next letter uppercase
        for (var i = 0; i < type.length; ++i) {
            var char = type.charAt(i);
            if (char === "_") {
                var nextChar = type.charAt(i + 1);
                var nextCharUpper = nextChar.toUpperCase();
                type = replaceAt(type, i + 1, nextCharUpper);
                type = removeAt(type, i);
            }
        }
        return type;
    };
};
exports.noBox = function () {
    return function (value, render) {
        var type = render(value);
        var extract = /(.*)Box<([a-zA-Z0-9]*)>(.*)/gm;
        var match = __spread(type.matchAll(extract));
        if (match.length === 0) {
            return type;
        }
        var strings = match[0];
        return strings[1] + strings[2] + strings[3];
    };
};
exports.toMsgPack = function () {
    return function (value, render) {
        var type = render(value);
        var modifier = "";
        if (type[type.length - 1] === "!") {
            type = type.substr(0, type.length - 1);
        }
        else {
            modifier = "nullable_";
        }
        if (type[0] === "[") {
            return modifier + "array";
        }
        if (type.startsWith("Map<")) {
            return modifier + "ext_generic_map";
        }
        switch (type) {
            case "Int":
                return modifier + "i32";
            case "Int8":
                return modifier + "i8";
            case "Int16":
                return modifier + "i16";
            case "Int32":
                return modifier + "i32";
            case "Int64":
                return modifier + "i64";
            case "UInt":
            case "UInt32":
                return modifier + "u32";
            case "UInt8":
                return modifier + "u8";
            case "UInt16":
                return modifier + "u16";
            case "UInt64":
                return modifier + "u64";
            case "String":
                return modifier + "string";
            case "Boolean":
                return modifier + "bool";
            case "Bytes":
                return modifier + "bytes";
            case "BigInt":
                return modifier + "bigint";
            case "BigNumber":
                return modifier + "bignumber";
            case "JSON":
                return modifier + "json";
            default:
                throw Error("Unknown toWasm type \"" + type + "\"");
        }
    };
};
exports.toWasmInit = function () {
    return function (value, render) {
        var type = render(value);
        var nullable = false;
        var nullableModifier = function (str) {
            return !nullable ? str : "None";
        };
        if (type[type.length - 1] === "!") {
            type = type.substr(0, type.length - 1);
        }
        else {
            nullable = true;
        }
        if (type[0] === "[") {
            return nullableModifier("vec![]");
        }
        if (type.startsWith("Map<")) {
            var openBracketIdx = type.indexOf("<");
            var closeBracketIdx = type.lastIndexOf(">");
            var _a = __read(type
                .substring(openBracketIdx + 1, closeBracketIdx)
                .split(",")
                .map(function (x) { return exports.toWasm()(x.trim(), render); }), 2), key = _a[0], value_1 = _a[1];
            return "Map::<" + key + ", " + value_1 + ">::new()";
        }
        switch (type) {
            case "Int":
            case "Int8":
            case "Int16":
            case "Int32":
            case "Int64":
            case "UInt":
            case "UInt8":
            case "UInt16":
            case "UInt32":
            case "UInt64":
                return nullableModifier("0");
            case "String":
                return nullableModifier("String::new()");
            case "Boolean":
                return nullableModifier("false");
            case "Bytes":
                return nullableModifier("vec![]");
            case "BigInt":
                return nullableModifier("BigInt::default()");
            case "BigNumber":
                return nullableModifier("BigNumber::default()");
            case "JSON":
                return nullableModifier("JSON::Value::Null");
            default:
                if (type.includes("Enum_")) {
                    return nullableModifier(exports.toWasm()(value, render) + "::_MAX_");
                }
                else {
                    return nullableModifier(exports.toWasm()(value, render) + "::new()");
                }
        }
    };
};
exports.toWasm = function () {
    return function (value, render) {
        var type = render(value);
        var objectType = false;
        var nullable = false;
        if (type[type.length - 1] === "!") {
            type = type.substr(0, type.length - 1);
        }
        else {
            nullable = true;
        }
        if (type[0] === "[") {
            return toWasmArray(type, nullable);
        }
        if (type.startsWith("Map<")) {
            return toWasmMap(type, nullable);
        }
        switch (type) {
            case "Int":
                type = "i32";
                break;
            case "Int8":
                type = "i8";
                break;
            case "Int16":
                type = "i16";
                break;
            case "Int32":
                type = "i32";
                break;
            case "Int64":
                type = "i64";
                break;
            case "UInt":
            case "UInt32":
                type = "u32";
                break;
            case "UInt8":
                type = "u8";
                break;
            case "UInt16":
                type = "u16";
                break;
            case "UInt64":
                type = "u64";
                break;
            case "String":
                type = "String";
                break;
            case "Boolean":
                type = "bool";
                break;
            case "Bytes":
                type = "Vec<u8>";
                break;
            case "BigInt":
                type = "BigInt";
                break;
            case "BigNumber":
                type = "BigNumber";
                break;
            case "JSON":
                type = "JSON::Value";
                break;
            default:
                if (type.includes("Enum_")) {
                    type = exports.toUpper()(type.replace("Enum_", ""), function (str) { return str; });
                }
                else {
                    objectType = true;
                    type = exports.toUpper()(type, function (str) { return str; });
                }
        }
        return objectType
            ? applyNullable(type, nullable)
            : applyNullable(type, nullable);
    };
};
exports.detectKeyword = function () {
    return function (value, render) {
        var type = render(value);
        // check if any of the keywords match the property name;
        // if there's a match, insert `m_` at the beginning of the property name.
        if (types_1.isKeyword(type)) {
            type = "m_" + type;
        }
        return type;
    };
};
var toWasmArray = function (type, nullable) {
    var result = type.match(/(\[)([[\]A-Za-z1-9_.!]+)(\])/);
    if (!result || result.length !== 4) {
        throw Error("Invalid Array: " + type);
    }
    var wasmType = exports.toWasm()(result[2], function (str) { return str; });
    return applyNullable("Vec<" + wasmType + ">", nullable);
};
var toWasmMap = function (type, nullable) {
    var firstOpenBracketIdx = type.indexOf("<");
    var lastCloseBracketIdx = type.lastIndexOf(">");
    if (!(firstOpenBracketIdx !== -1 && lastCloseBracketIdx !== -1)) {
        throw new Error("Invalid Map: " + type);
    }
    var keyValTypes = type
        .substring(firstOpenBracketIdx + 1, lastCloseBracketIdx)
        .split(",")
        .map(function (x) { return x.trim(); });
    if (keyValTypes.length !== 2 || !keyValTypes[0] || !keyValTypes[1]) {
        throw new Error("Invalid Map: " + type);
    }
    var keyType = exports.toWasm()(keyValTypes[0], function (str) { return str; });
    var valType = exports.toWasm()(keyValTypes[1], function (str) { return str; });
    return applyNullable("Map<" + keyType + ", " + valType + ">", nullable);
};
var applyNullable = function (type, nullable) {
    if (nullable) {
        return "Option<" + type + ">";
    }
    else {
        return type;
    }
};
//# sourceMappingURL=functions.js.map