"use strict";
/* eslint-disable no-useless-escape */
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable @typescript-eslint/ban-types */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveImportsAndParseSchemas = exports.resolveUseStatements = void 0;
var types_1 = require("./types");
var parse_1 = require("./parse");
var render_1 = require("./render");
var header_mustache_1 = require("./templates/header.mustache");
var env_1 = require("./env");
var schema_parse_1 = require("@polywrap/schema-parse");
var TYPE_NAME_REGEX = "[a-zA-Z0-9_]+";
function resolveUseStatements(schema, schemaPath, typeInfo) {
    return __awaiter(this, void 0, void 0, function () {
        var useKeywordCapture, useCapture, keywords, useStatements, importedModuleByNamespace, capabilitiesExt, parsedUses, _loop_1, parsedUses_1, parsedUses_1_1, parsedUse;
        var e_1, _a;
        return __generator(this, function (_b) {
            useKeywordCapture = /^[#]*["{3}]*use[ \n\t]/gm;
            useCapture = /[#]*["{3}]*use[ \n\t]*{([a-zA-Z0-9_, \n\t]+)}[ \n\t]*for[ \n\t]*(\w+)[ \n\t]/g;
            keywords = __spread(schema.matchAll(useKeywordCapture));
            useStatements = __spread(schema.matchAll(useCapture));
            if (keywords.length !== useStatements.length) {
                throw Error("Invalid use statement found in file " + schemaPath + ".\nPlease use one of the following syntaxes...\n" + types_1.SYNTAX_REFERENCE);
            }
            importedModuleByNamespace = {};
            typeInfo.importedModuleTypes.forEach(function (value) {
                importedModuleByNamespace[value.namespace] = value;
            });
            capabilitiesExt = [];
            parsedUses = parse_1.parseUse(useStatements);
            _loop_1 = function (parsedUse) {
                var importedModule = importedModuleByNamespace[parsedUse.namespace];
                if (!importedModule) {
                    throw Error("Invalid use statement: namespace used hasn't been imported");
                }
                var capabilities = parsedUse.usedTypes
                    .map(function (type) {
                    capabilitiesExt.push({
                        type: type,
                        uri: importedModule.uri,
                        namespace: parsedUse.namespace,
                    });
                    return schema_parse_1.createCapability({ type: type, enabled: true });
                })
                    .reduce(function (o1, o2) { return (__assign(__assign({}, o1), o2)); });
                typeInfo.interfaceTypes.push(schema_parse_1.createInterfaceDefinition({
                    type: parsedUse.namespace,
                    uri: importedModule.uri,
                    namespace: parsedUse.namespace,
                    capabilities: capabilities,
                }));
            };
            try {
                for (parsedUses_1 = __values(parsedUses), parsedUses_1_1 = parsedUses_1.next(); !parsedUses_1_1.done; parsedUses_1_1 = parsedUses_1.next()) {
                    parsedUse = parsedUses_1_1.value;
                    _loop_1(parsedUse);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (parsedUses_1_1 && !parsedUses_1_1.done && (_a = parsedUses_1.return)) _a.call(parsedUses_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return [2 /*return*/, capabilitiesExt];
        });
    });
}
exports.resolveUseStatements = resolveUseStatements;
function resolveImportsAndParseSchemas(schema, schemaPath, resolvers, noValidate) {
    if (noValidate === void 0) { noValidate = false; }
    return __awaiter(this, void 0, void 0, function () {
        var importKeywordCapture, externalImportCapture, localImportCapture, keywords, externalImportStatements, localImportStatments, totalStatements, interfaceCapture, implementInterfaceStatments, implementationsWithInterfaces, externalImportsToResolve, localImportsToResolve, subTypeInfo, externalImports, capabilitiesByModule, newSchema, typeInfo;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    importKeywordCapture = /^#+["{3}]*import\s/gm;
                    externalImportCapture = /#+["{3}]*import\s*(?:({[^}]+}|\*))\s*into\s*(\w+?)\s*from\s*[\"'`]([^\"'`\s]+)[\"'`]/g;
                    localImportCapture = /#+["{3}]*import\s*(?:({[^}]+}|\*))\s*from\s*[\"'`]([^\"'`\s]+)[\"'`]/g;
                    keywords = __spread(schema.matchAll(importKeywordCapture));
                    externalImportStatements = __spread(schema.matchAll(externalImportCapture));
                    localImportStatments = __spread(schema.matchAll(localImportCapture));
                    totalStatements = externalImportStatements.length + localImportStatments.length;
                    if (keywords.length !== totalStatements) {
                        throw Error("Invalid import statement found in file " + schemaPath + ".\nPlease use one of the following syntaxes...\n" + types_1.SYNTAX_REFERENCE);
                    }
                    interfaceCapture = new RegExp("type\\s+" + TYPE_NAME_REGEX + "\\s+implements\\s([^{]*){", "g");
                    implementInterfaceStatments = __spread(schema.matchAll(interfaceCapture));
                    implementationsWithInterfaces = parseInterfaces(implementInterfaceStatments);
                    externalImportsToResolve = parse_1.parseExternalImports(externalImportStatements);
                    localImportsToResolve = parse_1.parseLocalImports(localImportStatments, schemaPath);
                    subTypeInfo = {
                        objectTypes: [],
                        enumTypes: [],
                        interfaceTypes: [],
                        importedEnumTypes: [],
                        importedObjectTypes: [],
                        importedModuleTypes: [],
                        envType: schema_parse_1.createEnvDefinition({}),
                    };
                    return [4 /*yield*/, resolveExternalImports(externalImportsToResolve, resolvers.external, subTypeInfo)];
                case 1:
                    externalImports = _a.sent();
                    return [4 /*yield*/, resolveLocalImports(localImportsToResolve, resolvers.local, subTypeInfo, resolvers)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, resolveUseStatements(schema, schemaPath, subTypeInfo)];
                case 3:
                    capabilitiesByModule = _a.sent();
                    newSchema = schema
                        .replace(externalImportCapture, "")
                        .replace(localImportCapture, "");
                    // Remove all non documentation comments
                    newSchema = newSchema.replace(/#[^\n]*\n/g, "");
                    // Add the @imports directive
                    newSchema = addModuleImportsDirective(newSchema, externalImports);
                    // Add the @capability directive
                    newSchema = addCapabilityDirective(newSchema, capabilitiesByModule);
                    // Combine the new schema with the subTypeInfo
                    newSchema = schema_parse_1.header + newSchema + render_1.renderSchema(subTypeInfo, false);
                    newSchema = resolveInterfaces(newSchema, implementationsWithInterfaces);
                    // Replace types that have empty curly brackets with types that have no curly brackets
                    // because GraphQL parser doesn't support empty curly brackets but supports no curly brackets
                    newSchema = newSchema.replace(new RegExp("(type\\s+" + TYPE_NAME_REGEX + "[^{]*){\\s*}", "g"), "$1");
                    typeInfo = schema_parse_1.parseSchema(newSchema, { noValidate: noValidate });
                    return [2 /*return*/, typeInfo];
            }
        });
    });
}
exports.resolveImportsAndParseSchemas = resolveImportsAndParseSchemas;
// A transformation that converts all object definitions into
// imported object definitions
var extractObjectImportDependencies = function (importsFound, rootTypeInfo, namespace, uri) {
    var findImport = function (type, namespaceType, rootTypes, importedTypes, kind) {
        // Find this type's ObjectDefinition in the root type info
        var idx = rootTypes.findIndex(function (obj) { return obj.type === type; });
        var obj = undefined;
        if (idx === -1) {
            idx = importedTypes.findIndex(function (obj) { return obj.type === type; });
        }
        else {
            obj = rootTypes[idx];
        }
        if (idx === -1) {
            throw Error("extractObjectImportDependencies: Cannot find the dependent type within the root type info.\n" +
                ("Type: " + type + "\nTypeInfo: " + JSON.stringify(rootTypeInfo) + "\n" + namespace + "\n" + JSON.stringify(Object.keys(importsFound))));
        }
        else if (obj === undefined) {
            obj = importedTypes[idx];
        }
        // Create the new ImportedObjectDefinition
        return __assign(__assign({}, obj), { name: null, required: null, type: namespaceType, __namespaced: true, kind: kind,
            uri: uri,
            namespace: namespace, nativeType: type });
    };
    return {
        enter: {
            ObjectRef: function (def) {
                if (def.__namespaced) {
                    return def;
                }
                var type = def.type;
                var namespaceType = appendNamespace(namespace, type);
                if (!importsFound[namespaceType]) {
                    // Find the import
                    var importFound = findImport(type, namespaceType, rootTypeInfo.objectTypes, rootTypeInfo.importedObjectTypes, schema_parse_1.DefinitionKind.ImportedObject);
                    // Keep track of it
                    importsFound[importFound.type] = importFound;
                    // Traverse this newly added object
                    schema_parse_1.visitObjectDefinition(importFound, __assign({}, extractObjectImportDependencies(importsFound, rootTypeInfo, namespace, uri)));
                }
                return def;
            },
            InterfaceImplementedDefinition: function (def) {
                if (def.__namespaced) {
                    return def;
                }
                var type = def.type;
                var namespaceType = appendNamespace(namespace, type);
                if (!importsFound[namespaceType]) {
                    // Find the import
                    var importFound = findImport(type, namespaceType, rootTypeInfo.objectTypes, rootTypeInfo.importedObjectTypes, schema_parse_1.DefinitionKind.ImportedObject);
                    // Keep track of it
                    importsFound[importFound.type] = importFound;
                    // Traverse this newly added object
                    schema_parse_1.visitObjectDefinition(importFound, __assign({}, extractObjectImportDependencies(importsFound, rootTypeInfo, namespace, uri)));
                }
                return def;
            },
            EnumRef: function (def) {
                if (def.__namespaced) {
                    return def;
                }
                var namespaceType = appendNamespace(namespace, def.type);
                if (!importsFound[namespaceType]) {
                    // Find the import
                    var importFound = findImport(def.type, namespaceType, rootTypeInfo.enumTypes, rootTypeInfo.importedEnumTypes, schema_parse_1.DefinitionKind.ImportedEnum);
                    // Keep track of it
                    importsFound[importFound.type] = importFound;
                }
                return def;
            },
        },
    };
};
var namespaceTypes = function (namespace) { return ({
    enter: {
        ObjectRef: function (def) {
            if (def.__namespaced) {
                return def;
            }
            return __assign(__assign({}, def), { type: appendNamespace(namespace, def.type), __namespaced: true });
        },
        InterfaceImplementedDefinition: function (def) {
            if (def.__namespaced) {
                return def;
            }
            return __assign(__assign({}, def), { type: appendNamespace(namespace, def.type), __namespaced: true });
        },
        EnumRef: function (def) {
            if (def.__namespaced) {
                return def;
            }
            return __assign(__assign({}, def), { type: appendNamespace(namespace, def.type), __namespaced: true });
        },
    },
}); };
function appendNamespace(namespace, str) {
    return namespace + "_" + str;
}
function addModuleImportsDirective(schema, externalImports) {
    if (!externalImports.length) {
        return schema;
    }
    var result = schema;
    var modifySchema = function () {
        // Append the @imports(...) directive to the module type
        var typeCapture = /type\s+Module\s+([^{]*)\s*{/g;
        var importedTypes = "" + externalImports
            .map(function (type) { return "\"" + type + "\""; })
            .join(",\n    ");
        var replacementModuleStr = "type Module $1@imports(\n    types: [\n      " + importedTypes + "\n    ]\n    ) {";
        return result.replace(typeCapture, replacementModuleStr);
    };
    result = modifySchema();
    return result;
}
function addCapabilityDirective(schema, capabilities) {
    if (!capabilities.length) {
        return schema;
    }
    capabilities.forEach(function (capability) {
        var typeCapture = /type[ \n\t]+Module[ \n\t]+([^{]*)[ \n\t]*{/g;
        var replacementModuleStr = "type Module $1@capability(\ntype: \"" + capability.type + "\",\nuri: \"" + capability.uri + "\",\nnamespace: \"" + capability.namespace + "\"\n) {";
        schema = schema.replace(typeCapture, replacementModuleStr);
    });
    return schema;
}
function parseInterfaces(implementInterfaceStatments) {
    var e_2, _a;
    var implementationsWithInterfaces = [];
    try {
        for (var implementInterfaceStatments_1 = __values(implementInterfaceStatments), implementInterfaceStatments_1_1 = implementInterfaceStatments_1.next(); !implementInterfaceStatments_1_1.done; implementInterfaceStatments_1_1 = implementInterfaceStatments_1.next()) {
            var implementMatch = implementInterfaceStatments_1_1.value;
            var implementStr = implementMatch[1].trim();
            var typeCapture = new RegExp("type\\s+(" + TYPE_NAME_REGEX + ")\\s+", "g");
            var typeNameMatches = typeCapture.exec(implementMatch[0]);
            if (!typeNameMatches) {
                continue;
            }
            var typeName = typeNameMatches[1];
            var interfaces = __spread(implementStr.matchAll(new RegExp("(" + TYPE_NAME_REGEX + ")(&s+)*", "g"))).map(function (x) { return x[0]; });
            implementationsWithInterfaces.push({
                typeName: typeName,
                interfaces: interfaces,
            });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (implementInterfaceStatments_1_1 && !implementInterfaceStatments_1_1.done && (_a = implementInterfaceStatments_1.return)) _a.call(implementInterfaceStatments_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return implementationsWithInterfaces;
}
function resolveInterfaces(schema, implementationsWithInterfaces) {
    var e_3, _a, e_4, _b;
    var removeComments = function (body) {
        var bodyWithoutComments = body.replace(/"""[^"]*"""\s*/g, "");
        return bodyWithoutComments;
    };
    if (!implementationsWithInterfaces.length) {
        return schema;
    }
    var getAllUniqueInterfaces = function () {
        var allIntefaces = implementationsWithInterfaces
            .map(function (x) { return x.interfaces; })
            .reduce(function (acc, x) { return acc.concat(x); }, []);
        return __spread(new Set(allIntefaces));
    };
    var allInterfaces = getAllUniqueInterfaces();
    var interfacesWithBodies = [];
    var typeCapture = new RegExp("type\\s+(" + TYPE_NAME_REGEX + ")[^{]+{([^}]*)}", "g");
    var typeMatches = __spread(schema.matchAll(typeCapture));
    var _loop_2 = function (interfaceName) {
        var match = typeMatches.find(function (x) { return x[1] === interfaceName; });
        if (!match) {
            return "continue";
        }
        var body = match[2];
        if (!body) {
            return "continue";
        }
        body = removeComments(body);
        interfacesWithBodies.push({
            name: interfaceName,
            body: body,
        });
    };
    try {
        for (var allInterfaces_1 = __values(allInterfaces), allInterfaces_1_1 = allInterfaces_1.next(); !allInterfaces_1_1.done; allInterfaces_1_1 = allInterfaces_1.next()) {
            var interfaceName = allInterfaces_1_1.value;
            _loop_2(interfaceName);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (allInterfaces_1_1 && !allInterfaces_1_1.done && (_a = allInterfaces_1.return)) _a.call(allInterfaces_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    try {
        for (var implementationsWithInterfaces_1 = __values(implementationsWithInterfaces), implementationsWithInterfaces_1_1 = implementationsWithInterfaces_1.next(); !implementationsWithInterfaces_1_1.done; implementationsWithInterfaces_1_1 = implementationsWithInterfaces_1.next()) {
            var implementationWithInterfaces = implementationsWithInterfaces_1_1.value;
            var implementationTypeCapture = new RegExp("(type\\s+" + implementationWithInterfaces.typeName + "\\s+[^{]*){([^}]*)}");
            var bodiesOfInterfaces = implementationWithInterfaces.interfaces.map(function (interfaceName) {
                var _a;
                return (_a = interfacesWithBodies
                    .find(function (iwb) { return iwb.name === interfaceName; })) === null || _a === void 0 ? void 0 : _a.body.trim();
            });
            var bodiesOfInterfacesStr = bodiesOfInterfaces
                .filter(function (x) { return x; })
                .reduce(function (acc, x) { return acc + "\n" + x; }, "");
            schema = schema.replace(implementationTypeCapture, "$1{$2" + bodiesOfInterfacesStr + "\n}");
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (implementationsWithInterfaces_1_1 && !implementationsWithInterfaces_1_1.done && (_b = implementationsWithInterfaces_1.return)) _b.call(implementationsWithInterfaces_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return schema;
}
function resolveExternalImports(importsToResolve, resolveSchema, typeInfo) {
    return __awaiter(this, void 0, void 0, function () {
        var typesToImport, _loop_3, importsToResolve_1, importsToResolve_1_1, importToResolve, e_5_1;
        var e_5, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    typesToImport = {};
                    _loop_3 = function (importToResolve) {
                        var uri, namespace, importedTypes, schema, extTypeInfo, extTypesToImport, _loop_4, extTypesToImport_1, extTypesToImport_1_1, importedType, _loop_5, _a, _b, importName;
                        var e_6, _c, e_7, _d;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    uri = importToResolve.uri, namespace = importToResolve.namespace, importedTypes = importToResolve.importedTypes;
                                    return [4 /*yield*/, resolveSchema(uri)];
                                case 1:
                                    schema = _e.sent();
                                    if (!schema) {
                                        throw Error("Unable to resolve schema at \"" + uri + "\"");
                                    }
                                    extTypeInfo = schema_parse_1.parseSchema(schema);
                                    extTypesToImport = importedTypes;
                                    // If the importedTypes array contains the catch-all "*"
                                    // go ahead and add all extTypeInfo types to the importedTypes array
                                    if (extTypesToImport.indexOf("*") > -1) {
                                        extTypesToImport = __spread(extTypeInfo.objectTypes.map(function (x) { return x.type; }), extTypeInfo.enumTypes.map(function (x) { return x.type; }));
                                        if (extTypeInfo.moduleType) {
                                            extTypesToImport.push(extTypeInfo.moduleType.type);
                                        }
                                    }
                                    _loop_4 = function (importedType) {
                                        var extTypes = [];
                                        var visitorFunc = void 0;
                                        var trueType = void 0;
                                        // If it's a module type
                                        if (importedType === "Module") {
                                            if (!extTypeInfo.moduleType) {
                                                extTypeInfo.moduleType = schema_parse_1.createModuleDefinition({});
                                            }
                                            extTypes = [extTypeInfo.moduleType];
                                            visitorFunc = schema_parse_1.visitModuleDefinition;
                                            var type = extTypeInfo.moduleType;
                                            trueType = __assign(__assign({}, schema_parse_1.createImportedModuleDefinition(__assign(__assign({}, type), { required: undefined, uri: uri, nativeType: type.type, namespace: namespace }))), { methods: type.methods });
                                        }
                                        else if (importedType.endsWith("_Module")) {
                                            throw Error("Cannot import an import's imported module type. Tried to import " + importedType + " from " + uri + ".");
                                        }
                                        else {
                                            var objIdx = extTypeInfo.objectTypes.findIndex(function (def) { return def.type === importedType; });
                                            var impObjIdx = objIdx === -1 &&
                                                extTypeInfo.importedObjectTypes.findIndex(function (def) { return def.type === importedType; });
                                            var enumIdx = impObjIdx === -1 &&
                                                extTypeInfo.enumTypes.findIndex(function (def) { return def.type === importedType; });
                                            var impEnumIdx = enumIdx === -1 &&
                                                extTypeInfo.importedEnumTypes.findIndex(function (def) { return def.type === importedType; });
                                            if (objIdx > -1) {
                                                extTypes = extTypeInfo.objectTypes;
                                                visitorFunc = schema_parse_1.visitObjectDefinition;
                                                var type = extTypeInfo.objectTypes[objIdx];
                                                trueType = __assign(__assign({}, schema_parse_1.createImportedObjectDefinition(__assign(__assign({}, type), { type: appendNamespace(namespace, importedType), name: undefined, required: undefined, uri: uri, nativeType: type.type, namespace: namespace }))), { properties: type.properties });
                                            }
                                            else if (impObjIdx !== false && impObjIdx > -1) {
                                                extTypes = extTypeInfo.importedObjectTypes;
                                                visitorFunc = schema_parse_1.visitObjectDefinition;
                                                var type = extTypeInfo.importedObjectTypes[impObjIdx];
                                                trueType = __assign(__assign({}, schema_parse_1.createImportedObjectDefinition(__assign(__assign({}, type), { type: appendNamespace(namespace, importedType), name: undefined, required: undefined, uri: uri, nativeType: type.type, namespace: namespace }))), { properties: type.properties });
                                            }
                                            else if (enumIdx !== false && enumIdx > -1) {
                                                extTypes = extTypeInfo.enumTypes;
                                                visitorFunc = schema_parse_1.visitEnumDefinition;
                                                var type = extTypeInfo.enumTypes[enumIdx];
                                                trueType = schema_parse_1.createImportedEnumDefinition(__assign(__assign({}, type), { type: appendNamespace(namespace, importedType), name: undefined, required: undefined, uri: uri, nativeType: type.type, namespace: namespace }));
                                            }
                                            else if (impEnumIdx !== false && impEnumIdx > -1) {
                                                extTypes = extTypeInfo.importedEnumTypes;
                                                visitorFunc = schema_parse_1.visitEnumDefinition;
                                                var type = extTypeInfo.importedEnumTypes[impEnumIdx];
                                                trueType = schema_parse_1.createImportedEnumDefinition(__assign(__assign({}, type), { type: appendNamespace(namespace, importedType), name: undefined, required: undefined, uri: uri, nativeType: type.type, namespace: namespace }));
                                            }
                                        }
                                        if (!trueType) {
                                            throw Error("Cannot find type \"" + importedType + "\" in the schema at " + uri + ".\nFound: [ " + extTypes.map(function (type) { return type.type + " "; }) + "]");
                                        }
                                        if (!visitorFunc) {
                                            throw Error("visitorFunc has not been set, this should never happen.");
                                        }
                                        var namespacedType = appendNamespace(namespace, importedType);
                                        // Continue if we've already imported this type
                                        if (typesToImport[namespacedType]) {
                                            return "continue";
                                        }
                                        // Append the base type to our TypeInfo
                                        typesToImport[namespacedType] = __assign(__assign({}, trueType), { __namespaced: true });
                                        // Extract all object dependencies
                                        visitorFunc(trueType, extractObjectImportDependencies(typesToImport, extTypeInfo, namespace, uri));
                                    };
                                    try {
                                        // For each imported type to resolve
                                        for (extTypesToImport_1 = (e_6 = void 0, __values(extTypesToImport)), extTypesToImport_1_1 = extTypesToImport_1.next(); !extTypesToImport_1_1.done; extTypesToImport_1_1 = extTypesToImport_1.next()) {
                                            importedType = extTypesToImport_1_1.value;
                                            _loop_4(importedType);
                                        }
                                    }
                                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                                    finally {
                                        try {
                                            if (extTypesToImport_1_1 && !extTypesToImport_1_1.done && (_c = extTypesToImport_1.return)) _c.call(extTypesToImport_1);
                                        }
                                        finally { if (e_6) throw e_6.error; }
                                    }
                                    _loop_5 = function (importName) {
                                        var importType = typesToImport[importName];
                                        var destArray = void 0;
                                        var append = void 0;
                                        if (importType.kind === schema_parse_1.DefinitionKind.ImportedObject) {
                                            destArray = typeInfo.importedObjectTypes;
                                            append = function () {
                                                var importDef = importType;
                                                // Namespace all object types
                                                typeInfo.importedObjectTypes.push(schema_parse_1.visitImportedObjectDefinition(importDef, namespaceTypes(namespace)));
                                            };
                                        }
                                        else if (importType.kind === schema_parse_1.DefinitionKind.ImportedModule) {
                                            destArray = typeInfo.importedModuleTypes;
                                            append = function () {
                                                var importDef = importType;
                                                // Namespace all object types
                                                typeInfo.importedModuleTypes.push(schema_parse_1.visitImportedModuleDefinition(importDef, namespaceTypes(namespace)));
                                            };
                                        }
                                        else if (importType.kind === schema_parse_1.DefinitionKind.ImportedEnum) {
                                            destArray = typeInfo.importedEnumTypes;
                                            append = function () {
                                                typeInfo.importedEnumTypes.push(schema_parse_1.visitImportedEnumDefinition(importType, namespaceTypes(namespace)));
                                            };
                                        }
                                        else {
                                            throw Error("resolveExternalImports: This should never happen, unknown kind.\n" + JSON.stringify(importType, null, 2));
                                        }
                                        var found = destArray.findIndex(function (def) { return def.type === importType.type; }) > -1;
                                        if (!found) {
                                            append();
                                        }
                                    };
                                    try {
                                        // Add all imported types into the aggregate TypeInfo
                                        for (_a = (e_7 = void 0, __values(Object.keys(typesToImport))), _b = _a.next(); !_b.done; _b = _a.next()) {
                                            importName = _b.value;
                                            _loop_5(importName);
                                        }
                                    }
                                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                                    finally {
                                        try {
                                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                                        }
                                        finally { if (e_7) throw e_7.error; }
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    };
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 8]);
                    importsToResolve_1 = __values(importsToResolve), importsToResolve_1_1 = importsToResolve_1.next();
                    _b.label = 2;
                case 2:
                    if (!!importsToResolve_1_1.done) return [3 /*break*/, 5];
                    importToResolve = importsToResolve_1_1.value;
                    return [5 /*yield**/, _loop_3(importToResolve)];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    importsToResolve_1_1 = importsToResolve_1.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_5_1 = _b.sent();
                    e_5 = { error: e_5_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (importsToResolve_1_1 && !importsToResolve_1_1.done && (_a = importsToResolve_1.return)) _a.call(importsToResolve_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/, Promise.resolve(Object.keys(typesToImport))];
            }
        });
    });
}
function resolveLocalImports(importsToResolve, resolveSchema, typeInfo, resolvers) {
    return __awaiter(this, void 0, void 0, function () {
        var _loop_6, importsToResolve_2, importsToResolve_2_1, importToResolve, e_8_1;
        var e_8, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _loop_6 = function (importToResolve) {
                        var importedTypes, path, schema, localTypeInfo, extTypesToImport, typesToImport, _loop_7, extTypesToImport_2, extTypesToImport_2_1, importedType, _loop_8, _a, _b, importType;
                        var e_9, _c, e_10, _d;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    importedTypes = importToResolve.importedTypes, path = importToResolve.path;
                                    return [4 /*yield*/, resolveSchema(path)];
                                case 1:
                                    schema = _e.sent();
                                    if (!schema) {
                                        throw Error("Unable to resolve schema at \"" + path + "\"");
                                    }
                                    // Make sure the schema has the Polywrap header
                                    if (schema.indexOf("### Polywrap Header START ###") === -1) {
                                        schema = header_mustache_1.addHeader(schema);
                                    }
                                    return [4 /*yield*/, resolveImportsAndParseSchemas(schema, path, resolvers, true)];
                                case 2:
                                    localTypeInfo = _e.sent();
                                    extTypesToImport = importedTypes;
                                    // If the importedTypes array contains the catch-all "*"
                                    // go ahead and add all extTypeInfo types to the importedTypes array
                                    if (extTypesToImport.indexOf("*") > -1) {
                                        extTypesToImport = __spread(localTypeInfo.objectTypes.map(function (x) { return x.type; }), localTypeInfo.enumTypes.map(function (x) { return x.type; }));
                                        if (localTypeInfo.moduleType) {
                                            extTypesToImport.push(localTypeInfo.moduleType.type);
                                        }
                                    }
                                    typesToImport = {};
                                    _loop_7 = function (importedType) {
                                        if (importedType === "Module") {
                                            throw Error("Importing module types from local schemas is prohibited. Tried to import from " + path + ".");
                                        }
                                        var type = void 0;
                                        var visitorFunc;
                                        if (schema_parse_1.isEnvType(importedType)) {
                                            visitorFunc = schema_parse_1.visitEnvDefinition;
                                            type = schema_parse_1.isClientEnvType(importedType)
                                                ? localTypeInfo.envType.client
                                                : localTypeInfo.envType.sanitized;
                                        }
                                        else {
                                            var objectIdx = localTypeInfo.objectTypes.findIndex(function (type) { return type.type === importedType; });
                                            var enumIdx = objectIdx === -1 &&
                                                localTypeInfo.enumTypes.findIndex(function (type) { return type.type === importedType; });
                                            if (objectIdx > -1) {
                                                visitorFunc = schema_parse_1.visitObjectDefinition;
                                                type = localTypeInfo.objectTypes[objectIdx];
                                            }
                                            else if (enumIdx > -1) {
                                                visitorFunc = schema_parse_1.visitEnumDefinition;
                                                type = localTypeInfo.enumTypes.find(function (type) { return type.type === importedType; });
                                            }
                                        }
                                        if (!type) {
                                            throw Error("Cannot find type \"" + importedType + "\" in the schema at " + path + ".\nFound: [ " + localTypeInfo.objectTypes.map(function (type) { return type.type + " "; }) + "]");
                                        }
                                        typesToImport[type.type] = type;
                                        var findImport = function (def, rootTypes) {
                                            // Skip objects that we've already processed
                                            if (typesToImport[def.type]) {
                                                return def;
                                            }
                                            // Find the ObjectDefinition
                                            var idx = rootTypes.findIndex(function (obj) { return obj.type === def.type; });
                                            if (idx === -1) {
                                                throw Error("resolveLocalImports: Cannot find the requested type within the TypeInfo.\n" +
                                                    ("Type: " + def.type + "\nTypeInfo: " + JSON.stringify(localTypeInfo)));
                                            }
                                            var objectDefinition = rootTypes[idx];
                                            if (!visitedTypes[objectDefinition.type]) {
                                                if (objectDefinition.kind !== schema_parse_1.DefinitionKind.Enum) {
                                                    visitedTypes[objectDefinition.type] = true;
                                                    visitType(objectDefinition);
                                                }
                                            }
                                            typesToImport[def.type] = __assign(__assign({}, objectDefinition), { name: null, required: null });
                                            return def;
                                        };
                                        var visitedTypes = {};
                                        var visitType = function (type) {
                                            visitorFunc(type, {
                                                enter: {
                                                    ObjectRef: function (def) {
                                                        return findImport(def, __spread(localTypeInfo.objectTypes, localTypeInfo.importedObjectTypes));
                                                    },
                                                    EnumRef: function (def) {
                                                        return findImport(def, __spread(localTypeInfo.enumTypes, localTypeInfo.importedEnumTypes));
                                                    },
                                                    InterfaceImplementedDefinition: function (def) {
                                                        return findImport(def, __spread(localTypeInfo.objectTypes, localTypeInfo.importedObjectTypes));
                                                    },
                                                },
                                            });
                                        };
                                        visitedTypes[type.type] = true;
                                        visitType(type);
                                    };
                                    try {
                                        for (extTypesToImport_2 = (e_9 = void 0, __values(extTypesToImport)), extTypesToImport_2_1 = extTypesToImport_2.next(); !extTypesToImport_2_1.done; extTypesToImport_2_1 = extTypesToImport_2.next()) {
                                            importedType = extTypesToImport_2_1.value;
                                            _loop_7(importedType);
                                        }
                                    }
                                    catch (e_9_1) { e_9 = { error: e_9_1 }; }
                                    finally {
                                        try {
                                            if (extTypesToImport_2_1 && !extTypesToImport_2_1.done && (_c = extTypesToImport_2.return)) _c.call(extTypesToImport_2);
                                        }
                                        finally { if (e_9) throw e_9.error; }
                                    }
                                    _loop_8 = function (importType) {
                                        var _a, _b;
                                        if (schema_parse_1.isEnvType(importType)) {
                                            if (schema_parse_1.isClientEnvType(importType)) {
                                                if (!typeInfo.envType.client) {
                                                    typeInfo.envType.client = schema_parse_1.createObjectDefinition({
                                                        type: schema_parse_1.envTypes.ClientEnv,
                                                    });
                                                }
                                                var sharedEnv = localTypeInfo.envType.client;
                                                env_1.checkDuplicateEnvProperties(typeInfo.envType.client, sharedEnv.properties);
                                                (_a = typeInfo.envType.client.properties).push.apply(_a, __spread(sharedEnv.properties));
                                            }
                                            else {
                                                if (!typeInfo.envType.sanitized) {
                                                    typeInfo.envType.sanitized = schema_parse_1.createObjectDefinition({
                                                        type: schema_parse_1.envTypes.Env,
                                                    });
                                                }
                                                var sharedEnv = localTypeInfo.envType.sanitized;
                                                env_1.checkDuplicateEnvProperties(typeInfo.envType.sanitized, sharedEnv.properties);
                                                (_b = typeInfo.envType.sanitized.properties).push.apply(_b, __spread(sharedEnv.properties));
                                            }
                                        }
                                        else if (schema_parse_1.isKind(typesToImport[importType], schema_parse_1.DefinitionKind.ImportedObject)) {
                                            if (typeInfo.importedObjectTypes.findIndex(function (def) { return def.type === importType; }) === -1) {
                                                typeInfo.importedObjectTypes.push(typesToImport[importType]);
                                            }
                                        }
                                        else if (schema_parse_1.isKind(typesToImport[importType], schema_parse_1.DefinitionKind.Object)) {
                                            if (typeInfo.objectTypes.findIndex(function (def) { return def.type === importType; }) ===
                                                -1) {
                                                typeInfo.objectTypes.push(typesToImport[importType]);
                                            }
                                        }
                                        else if (schema_parse_1.isKind(typesToImport[importType], schema_parse_1.DefinitionKind.ImportedEnum)) {
                                            if (typeInfo.importedEnumTypes.findIndex(function (def) { return def.type === importType; }) === -1) {
                                                typeInfo.importedEnumTypes.push(typesToImport[importType]);
                                            }
                                        }
                                        else if (schema_parse_1.isKind(typesToImport[importType], schema_parse_1.DefinitionKind.Enum)) {
                                            if (typeInfo.enumTypes.findIndex(function (def) { return def.type === importType; }) === -1) {
                                                typeInfo.enumTypes.push(typesToImport[importType]);
                                            }
                                        }
                                    };
                                    try {
                                        // Add all imported types into the aggregate TypeInfo
                                        for (_a = (e_10 = void 0, __values(Object.keys(typesToImport))), _b = _a.next(); !_b.done; _b = _a.next()) {
                                            importType = _b.value;
                                            _loop_8(importType);
                                        }
                                    }
                                    catch (e_10_1) { e_10 = { error: e_10_1 }; }
                                    finally {
                                        try {
                                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                                        }
                                        finally { if (e_10) throw e_10.error; }
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    };
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 8]);
                    importsToResolve_2 = __values(importsToResolve), importsToResolve_2_1 = importsToResolve_2.next();
                    _b.label = 2;
                case 2:
                    if (!!importsToResolve_2_1.done) return [3 /*break*/, 5];
                    importToResolve = importsToResolve_2_1.value;
                    return [5 /*yield**/, _loop_6(importToResolve)];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    importsToResolve_2_1 = importsToResolve_2.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_8_1 = _b.sent();
                    e_8 = { error: e_8_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (importsToResolve_2_1 && !importsToResolve_2_1.done && (_a = importsToResolve_2.return)) _a.call(importsToResolve_2);
                    }
                    finally { if (e_8) throw e_8.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/];
            }
        });
    });
}
//# sourceMappingURL=resolve.js.map