type i8 = number;
type i16 = number;
type i32 = number;
type i64 = bigint;
type isize = number;
type u8 = number;
type u16 = number;
type u32 = number;
type u64 = bigint;
type usize = number;
type f32 = number;
type f64 = number;
type bool = boolean | number;
export abstract class Read {
  static wrap(ptr: usize): Read;
  valueOf(): usize;
  readBool(): bool;
  readInt8(): i8;
  readInt16(): i16;
  readInt32(): i32;
  readUInt8(): u8;
  readUInt16(): u16;
  readUInt32(): u32;
  readFloat32(): f32;
  readFloat64(): f64;
  readStringLength(): u32;
  readString(): usize;
  readBytesLength(): u32;
  readBytes(): usize;
  readBigInt(): usize;
  readBigNumber(): usize;
  readJSON(): usize;
  readArrayLength(): u32;
  readMapLength(): u32;
  readNullableBool(): usize;
  readNullableInt8(): usize;
  readNullableInt16(): usize;
  readNullableInt32(): usize;
  readNullableUInt8(): usize;
  readNullableUInt16(): usize;
  readNullableUInt32(): usize;
  readNullableFloat32(): usize;
  readNullableFloat64(): usize;
  readNullableString(): usize;
  readNullableBytes(): usize;
  readNullableBigInt(): usize;
  readNullableBigNumber(): usize;
  readNullableJSON(): usize;
  isNextNil(): bool;
  isNextString(): bool;
  context(): usize;
  constructor();
}
export class ReadDecoder extends Read {
  static wrap(ptr: usize): ReadDecoder;
  valueOf(): usize;
  readBool(): bool;
  readInt8(): i8;
  readInt16(): i16;
  readInt32(): i32;
  readUInt8(): u8;
  readUInt16(): u16;
  readUInt32(): u32;
  readFloat32(): f32;
  readFloat64(): f64;
  readStringLength(): u32;
  readString(): usize;
  readBytesLength(): u32;
  readBytes(): usize;
  readBigInt(): usize;
  readBigNumber(): usize;
  readJSON(): usize;
  readArrayLength(): u32;
  readArray(fn: usize): usize;
  readMapLength(): u32;
  readNullableBool(): usize;
  readNullableInt8(): usize;
  readNullableInt16(): usize;
  readNullableInt32(): usize;
  readNullableUInt8(): usize;
  readNullableUInt16(): usize;
  readNullableUInt32(): usize;
  readNullableFloat32(): usize;
  readNullableFloat64(): usize;
  readNullableString(): usize;
  readNullableBytes(): usize;
  readNullableBigInt(): usize;
  readNullableBigNumber(): usize;
  readNullableJSON(): usize;
  isNextNil(): bool;
  isNextString(): bool;
  context(): usize;
  constructor(ua: usize, context?: usize);
}
export abstract class Write {
  static wrap(ptr: usize): Write;
  valueOf(): usize;
  writeNil(): void;
  writeBool(value: bool): void;
  writeInt8(value: i8): void;
  writeInt16(value: i16): void;
  writeInt32(value: i32): void;
  writeUInt8(value: u8): void;
  writeUInt16(value: u16): void;
  writeUInt32(value: u32): void;
  writeFloat32(value: f32): void;
  writeFloat64(value: f64): void;
  writeStringLength(length: u32): void;
  writeString(value: usize): void;
  writeBytesLength(length: u32): void;
  writeBytes(value: usize): void;
  writeBigInt(value: usize): void;
  writeBigNumber(value: usize): void;
  writeJSON(value: usize): void;
  writeArrayLength(length: u32): void;
  writeMapLength(length: u32): void;
  writeNullableBool(value: usize): void;
  writeNullableInt8(value: usize): void;
  writeNullableInt16(value: usize): void;
  writeNullableInt32(value: usize): void;
  writeNullableUInt8(value: usize): void;
  writeNullableUInt16(value: usize): void;
  writeNullableUInt32(value: usize): void;
  writeNullableFloat32(value: usize): void;
  writeNullableFloat64(value: usize): void;
  writeNullableString(value: usize): void;
  writeNullableBytes(value: usize): void;
  writeNullableBigInt(value: usize): void;
  writeNullableBigNumber(value: usize): void;
  writeNullableJSON(value: usize): void;
  context(): usize;
  constructor();
}
export class WriteEncoder extends Write {
  static wrap(ptr: usize): WriteEncoder;
  valueOf(): usize;
  writeNil(): void;
  writeBool(value: bool): void;
  writeInt8(value: i8): void;
  writeInt16(value: i16): void;
  writeInt32(value: i32): void;
  writeUInt8(value: u8): void;
  writeUInt16(value: u16): void;
  writeUInt32(value: u32): void;
  writeFloat32(value: f32): void;
  writeFloat64(value: f64): void;
  writeStringLength(length: u32): void;
  writeString(value: usize): void;
  writeBytesLength(length: u32): void;
  writeBytes(value: usize): void;
  writeBigInt(value: usize): void;
  writeBigNumber(value: usize): void;
  writeJSON(value: usize): void;
  writeArrayLength(length: u32): void;
  writeMapLength(length: u32): void;
  writeNullableBool(value: usize): void;
  writeNullableInt8(value: usize): void;
  writeNullableInt16(value: usize): void;
  writeNullableInt32(value: usize): void;
  writeNullableUInt8(value: usize): void;
  writeNullableUInt16(value: usize): void;
  writeNullableUInt32(value: usize): void;
  writeNullableFloat32(value: usize): void;
  writeNullableFloat64(value: usize): void;
  writeNullableString(value: usize): void;
  writeNullableBytes(value: usize): void;
  writeNullableBigInt(value: usize): void;
  writeNullableBigNumber(value: usize): void;
  writeNullableJSON(value: usize): void;
  context(): usize;
  constructor(ua: usize, sizer: usize, context?: usize);
}
export class WriteSizer extends Write {
  static wrap(ptr: usize): WriteSizer;
  valueOf(): usize;
  writeNil(): void;
  writeBool(_value: bool): void;
  writeInt8(value: i8): void;
  writeInt16(value: i16): void;
  writeInt32(value: i32): void;
  writeUInt8(value: u8): void;
  writeUInt16(value: u16): void;
  writeUInt32(value: u32): void;
  writeFloat32(_value: f32): void;
  writeFloat64(_value: f64): void;
  writeStringLength(length: u32): void;
  writeString(value: usize): void;
  writeBytesLength(length: u32): void;
  writeBytes(value: usize): void;
  writeBigInt(value: usize): void;
  writeBigNumber(value: usize): void;
  writeJSON(value: usize): void;
  writeArrayLength(length: u32): void;
  writeMapLength(length: u32): void;
  writeNullableBool(value: usize): void;
  writeNullableInt8(value: usize): void;
  writeNullableInt16(value: usize): void;
  writeNullableInt32(value: usize): void;
  writeNullableUInt8(value: usize): void;
  writeNullableUInt16(value: usize): void;
  writeNullableUInt32(value: usize): void;
  writeNullableFloat32(value: usize): void;
  writeNullableFloat64(value: usize): void;
  writeNullableString(value: usize): void;
  writeNullableBytes(value: usize): void;
  writeNullableBigInt(value: usize): void;
  writeNullableBigNumber(value: usize): void;
  writeNullableJSON(value: usize): void;
  context(): usize;
  constructor(context?: usize);
  length: i32;
  extByteLengths: usize;
}
export class JSONDeserializer {
  static wrap(ptr: usize): JSONDeserializer;
  valueOf(): usize;
  constructor(val: usize);
  decode_bool(): bool;
  decode_string(): usize;
  decode_arraybuffer(): usize;
  decode_arraybuffer_view(): usize;
  decode_u8(): u8;
  decode_i8(): i8;
  decode_u16(): u16;
  decode_i16(): i16;
  decode_u32(): u32;
  decode_i32(): i32;
  decode_u64(): u64;
  decode_i64(): i64;
  decode_f32(): f32;
  decode_f64(): f64;
  valStack: usize;
  pushVal(obj: usize): void;
  popVal(): usize;
  get currentVal(): usize;
  get currentObj(): usize;
  get currentArr(): usize;
  decode_int(): u8;
  decode_int(): i8;
  decode_int(): u16;
  decode_int(): i16;
  decode_int(): u32;
  decode_int(): i32;
  decode_long(): u64;
  decode_long(): i64;
  decode_float(): f32;
  decode_float(): f64;
}
export class JSONSerializer {
  static wrap(ptr: usize): JSONSerializer;
  valueOf(): usize;
  get_encoded_object(): usize;
  encode_bool(value: bool): void;
  encode_string(value: usize): void;
  encode_arraybuffer(value: usize): void;
  encode_arraybuffer_view(value: usize): void;
  encode_u8(value: u8): void;
  encode_i8(value: i8): void;
  encode_u16(value: u16): void;
  encode_i16(value: i16): void;
  encode_u32(value: u32): void;
  encode_i32(value: i32): void;
  encode_u64(value: u64): void;
  encode_i64(value: i64): void;
  encode_f32(value: f32): void;
  encode_f64(value: f64): void;
  valueStack: usize;
  starting_object: bool;
  inner_encode: usize;
  peek(): usize;
  push(v: usize): void;
  encode_small_int(value: u8): void;
  encode_small_int(value: i8): void;
  encode_small_int(value: u16): void;
  encode_small_int(value: i16): void;
  encode_small_int(value: u32): void;
  encode_small_int(value: i32): void;
  constructor();
}
export namespace JSON {
  export abstract class Value {
    static wrap(ptr: usize): Value;
    valueOf(): usize;
    static String(str: usize): usize;
    static Number(num: f64): usize;
    static Float(num: f64): usize;
    static Integer(num: i64): usize;
    static Bool(b: bool): usize;
    static Null(): usize;
    static Array(): usize;
    static Object(): usize;
    get isString(): bool;
    get isNum(): bool;
    get isFloat(): bool;
    get isInteger(): bool;
    get isBool(): bool;
    get isNull(): bool;
    get isArr(): bool;
    get isObj(): bool;
    stringify(): usize;
    toString(): usize;
    constructor();
  }
  export class Str extends Value {
    static wrap(ptr: usize): Str;
    valueOf(): usize;
    stringify(): usize;
    toString(): usize;
    constructor(_str: usize);
    _str: usize;
    valueOf(): usize;
  }
  export class Num extends Value {
    static wrap(ptr: usize): Num;
    valueOf(): usize;
    stringify(): usize;
    constructor(_num: f64);
    _num: f64;
    valueOf(): f64;
  }
  export class Float extends Num {
    static wrap(ptr: usize): Float;
    valueOf(): usize;
    constructor(_num: f64);
  }
  export class Integer extends Value {
    static wrap(ptr: usize): Integer;
    valueOf(): usize;
    stringify(): usize;
    constructor(_num: i64);
    _num: i64;
    valueOf(): i64;
  }
  export class Null extends Value {
    static wrap(ptr: usize): Null;
    valueOf(): usize;
    stringify(): usize;
    constructor();
  }
  export class Bool extends Value {
    static wrap(ptr: usize): Bool;
    valueOf(): usize;
    stringify(): usize;
    constructor(_bool: bool);
    _bool: bool;
    valueOf(): bool;
  }
  export class Arr extends Value {
    static wrap(ptr: usize): Arr;
    valueOf(): usize;
    stringify(): usize;
    constructor();
    _arr: usize;
    push(obj: usize): void;
    valueOf(): usize;
  }
  export class Obj extends Value {
    static wrap(ptr: usize): Obj;
    valueOf(): usize;
    stringify(): usize;
    _obj: usize;
    constructor();
    get keys(): usize;
    valueOf(): usize;
    set(key: usize, value: usize): void;
    has(key: usize): bool;
    get(key: usize): usize;
    getValue(key: usize): usize;
    getString(key: usize): usize;
    getNum(key: usize): usize;
    getFloat(key: usize): usize;
    getInteger(key: usize): usize;
    getBool(key: usize): usize;
    getArr(key: usize): usize;
    getObj(key: usize): usize;
  }
}
export class BigInt {
  static wrap(ptr: usize): BigInt;
  valueOf(): usize;
  static from(val: usize): usize;
  static fromString(bigInteger: usize, radix?: i32): usize;
  static fromUInt16(val: u16): usize;
  static fromUInt32(val: u32): usize;
  static fromUInt64(val: u64): usize;
  static fromInt16(val: i16): usize;
  static fromInt32(val: i32): usize;
  static fromInt64(val: i64): usize;
  static get ZERO(): usize;
  static get ONE(): usize;
  static get NEG_ONE(): usize;
  static divOp(left: usize, right: usize): usize;
  get isNegative(): bool;
  copy(): usize;
  opposite(): usize;
  abs(): usize;
  toString(radix?: i32): usize;
  toInt32(): i32;
  toInt64(): i64;
  toUInt32(): u32;
  toUInt64(): u64;
  eq(other: usize): bool;
  ne(other: usize): bool;
  lt(other: usize): bool;
  lte(other: usize): bool;
  gt(other: usize): bool;
  gte(other: usize): bool;
  compareTo(other: usize): i32;
  magCompareTo(other: usize): i32;
  add(other: usize): usize;
  sub(other: usize): usize;
  mul2(): usize;
  div2(): usize;
  mulPowTwo(k: i32): usize;
  divPowTwo(k: i32): usize;
  modPowTwo(k: i32): usize;
  leftShift(k: i32): usize;
  rightShift(k: i32): usize;
  mul(other: usize): usize;
  pow(k: i32): usize;
  square(): usize;
  sqrt(): usize;
  div(other: usize): usize;
  mod(other: usize): usize;
  divMod(other: usize): usize;
  addInt(b: u32): usize;
  subInt(b: u32): usize;
  mulInt(b: u32): usize;
  divInt(b: u32): usize;
  modInt(b: u32): u32;
  divModInt(b: u32): usize;
  roundedDivInt(b: u32): usize;
  bitwiseNot(): usize;
  bitwiseAnd(other: usize): usize;
  bitwiseOr(other: usize): usize;
  bitwiseXor(other: usize): usize;
  countBits(): i32;
  isOdd(): bool;
  isZero(): bool;
}
export class BigNumber {
  static wrap(ptr: usize): BigNumber;
  valueOf(): usize;
  static DEFAULT_PRECISION: i32;
  static DEFAULT_ROUNDING: i32;
  static MAX_POWER: i32;
  static ONE: usize;
  static HALF: usize;
  static from(val: usize): usize;
  static from(val: i32): usize;
  static fromFraction(numerator: usize, denominator: usize, precision?: i32, rounding?: i32): usize;
  static fromString(val: usize, precision?: i32, rounding?: i32): usize;
  static fromBigInt(val: usize): usize;
  static fromFloat64(val: f64, precision?: i32, rounding?: i32): usize;
  readonly m: usize;
  readonly e: i32;
  get precision(): i32;
  get isInteger(): bool;
  constructor(m: usize, e: i32, precision: i32);
  copy(): usize;
  opposite(): usize;
  abs(): usize;
  reciprocal(precision?: i32, rounding?: i32): usize;
  toString(): usize;
  toFixed(places?: i32, rounding?: i32): usize;
  toSignificant(digits?: i32, rounding?: i32): usize;
  toBigInt(): usize;
  toFloat64(): f64;
  eq(other: usize): bool;
  ne(other: usize): bool;
  lt(other: usize): bool;
  lte(other: usize): bool;
  gt(other: usize): bool;
  gte(other: usize): bool;
  compareTo(other: usize): i32;
  magCompareTo(other: usize): i32;
  add(other: usize, precision?: i32, rounding?: i32): usize;
  sub(other: usize, precision?: i32, rounding?: i32): usize;
  sub(other: i32, precision?: i32, rounding?: i32): usize;
  mul(other: usize, precision?: i32, rounding?: i32): usize;
  square(precision?: i32, rounding?: i32): usize;
  div(other: usize, precision?: i32, rounding?: i32): usize;
  sqrt(precision?: i32, rounding?: i32): usize;
  pow(k: i32, precision?: i32, rounding?: i32): usize;
  get isNegative(): bool;
  isZero(): bool;
  floor(): usize;
  ceil(): usize;
  setScale(e: i32, rounding?: i32): usize;
  round(precision?: i32, rounding?: i32): usize;
}
export enum Rounding {
  UP,
  DOWN,
  CEIL,
  FLOOR,
  HALF_UP,
  HALF_DOWN,
  HALF_EVEN,
  NONE,
}
export class Context {
  static wrap(ptr: usize): Context;
  valueOf(): usize;
  constructor(description?: usize);
  isEmpty(): bool;
  get length(): i32;
  push(item: usize, type?: usize, info?: usize): void;
  pop(): usize;
  toString(): usize;
  printWithContext(message: usize): usize;
}
export function __wrap_debug_log(ptr: u32, len: u32): void;
export function wrap_debug_log(msg: usize): void;
export function __wrap_abort(msg_ptr: u32, msg_len: u32, file_ptr: u32, file_len: u32, line: u32, column: u32): void;
export function wrap_abort(msg: usize, file: usize, line: u32, column: u32): void;
export function __wrap_invoke_args(method_ptr: u32, args_ptr: u32): void;
export function __wrap_invoke_result(ptr: u32, len: u32): void;
export function __wrap_invoke_error(ptr: u32, len: u32): void;
export class InvokeArgs {
  static wrap(ptr: usize): InvokeArgs;
  valueOf(): usize;
  method: usize;
  args: usize;
  constructor(method: usize, args: usize);
}
export function wrap_invoke_args(method_size: u32, args_size: u32): usize;
export function wrap_invoke(args: usize, fn: usize): bool;
export function __wrap_subinvoke(uri_ptr: u32, uri_len: u32, method_ptr: u32, method_len: u32, input_ptr: u32, input_len: u32): bool;
export function __wrap_subinvoke_result_len(): u32;
export function __wrap_subinvoke_result(ptr: u32): void;
export function __wrap_subinvoke_error_len(): u32;
export function __wrap_subinvoke_error(ptr: u32): void;
export function wrap_subinvoke(uri: usize, method: usize, input: usize): usize;
export function __wrap_subinvokeImplementation(interface_uri_ptr: u32, interface_uri_len: u32, impl_uri_ptr: u32, impl_uri_len: u32, method_ptr: u32, method_len: u32, input_ptr: u32, input_len: u32): bool;
export function __wrap_subinvokeImplementation_result_len(): u32;
export function __wrap_subinvokeImplementation_result(ptr: u32): void;
export function __wrap_subinvokeImplementation_error_len(): u32;
export function __wrap_subinvokeImplementation_error(ptr: u32): void;
export function wrap_subinvokeImplementation(interfaceUri: usize, implUri: usize, method: usize, input: usize): usize;
export function __wrap_load_env(enviroment_ptr: u32): void;
export function __wrap_sanitize_env_args(args_ptr: u32): void;
export function __wrap_sanitize_env_result(ptr: u32, len: u32): void;
export function wrap_load_env(env_size: u32): usize;
export function wrap_sanitize_env(args_size: u32, fn: usize): void;
export function __wrap_getImplementations(uri_ptr: u32, uri_len: u32): bool;
export function __wrap_getImplementations_result_len(): u32;
export function __wrap_getImplementations_result(ptr: u32): void;
export function wrap_getImplementations(uri: usize): usize;
export const memory: WebAssembly.Memory;
export const __setArgumentsLength: ((n: i32) => void) | undefined;
